<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>タスク管理アプリ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        /* Custom font size for project name to fit smaller icons */
        .text-\[10px\] {
            font-size: 10px;
        }
        /* Custom scrollbar for dark mode */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #2d3748; /* Darker gray */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: #4a5568; /* Medium gray */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280; /* Lighter gray on hover */
        }

        /* Fade transition classes */
        .fade-enter-active, .fade-leave-active {
            transition: opacity 0.3s ease-in-out;
        }
        .fade-enter-from, .fade-leave-to {
            opacity: 0;
        }
        .fade-enter-to, .fade-leave-from {
            opacity: 1;
        }

        /* Custom drag-and-drop styles */
        .dragging {
            opacity: 0.5;
            border: 2px dashed #6366f1; /* Indigo-500 */
        }
        .drag-over {
            /* For containers (active-tasks-container, completed-tasks-container) */
            border: 2px dashed #9ca3af; /* Gray-400 dashed border */
            background-color: #4a5568; /* Medium gray (変更後の色) */
        }
        .drag-over-top {
            /* For task cards: indicates insertion before this card */
            border-top: 2px solid #9ca3af; /* Gray-400 solid line */
        }
        .drag-over-bottom {
            /* For task cards: indicates insertion after this card */
            border-bottom: 2px solid #9ca3af; /* Gray-400 solid line */
        }
        .project-cell.drag-over {
            border: 2px dashed #6366f1;
        }
        .project-cell.highlight {
            border: 2px solid #6366f1; /* Highlight for move mode */
        }
        .task-card-wrapper {
            position: relative;
            overflow-x: hidden; /* Prevent horizontal scrollbar on wrapper */
        }
        .task-card-wrapper.wrapper-dragging {
            z-index: 20;
        }

        .task-delete-overlay, .task-complete-overlay {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
            display: flex;
            align-items: center;
            padding: 0 1rem;
            font-weight: bold;
            font-size: 1.5rem;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            pointer-events: none;
            z-index: 10;
        }
        .task-delete-overlay {
            right: 0;
            justify-content: flex-end;
            color: #ef4444; /* red-500 */
        }
        .task-complete-overlay {
            left: 0;
            justify-content: flex-start;
            color: #06b6d4; /* cyan-500 */
        }

        #app-container {
            transition: height 0.3s ease-in-out;
        }
        
        /* ▼▼▼ 追加: 表示数切り替えトグル用CSS ▼▼▼ */
        #display-toggle:checked ~ .toggle-bg {
            background-color: #4f46e5; /* indigo-600 */
        }
        #display-toggle:checked ~ .dot {
            transform: translateX(1.5rem); /* 24px */
        }
        /* ▲▲▲ 追加ここまで ▲▲▲ */

        @media (max-width: 400px) {
            #task-screen > div:first-child {
                flex-wrap: wrap;
                justify-content: flex-end;
            }
            #project-name-input {
                width: 100%;
                margin-right: 0;
                margin-bottom: 0.75rem; /* 12px */
            }
            #app-container {
                padding: 0.5rem; /* 8px */
            }
        }

        @media print {
            .no-print {
                display: none !important;
            }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen flex flex-col items-center justify-center p-2">

    <div id="app-container" class="relative w-full max-w-4xl bg-gray-800 rounded-xl shadow-2xl p-6 flex flex-col">

        <div id="home-screen" class="absolute inset-0 flex flex-col p-6 fade-enter-active fade-enter-to pb-4">
            <div class="flex justify-between items-center mb-8">
                <h1 class="text-3xl font-bold text-indigo-400">｜プロジェクト一覧</h1>
                <label for="display-toggle" class="relative flex items-center cursor-pointer">
                    <input type="checkbox" id="display-toggle" class="sr-only">
                    <div class="toggle-bg block bg-gray-600 w-14 h-8 rounded-full"></div>
                    <div class="dot absolute left-1 top-1 bg-white w-6 h-6 rounded-full transition-transform"></div>
                </label>
            </div>
            <div id="project-grid" class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-8 gap-4 pb-4">
                </div>
        </div>

        <div id="task-screen" class="absolute inset-0 flex flex-col p-6 bg-gray-800 fade-leave-to opacity-0 pointer-events-none">
            <div class="flex justify-between items-center mb-6">
                <input type="text" id="project-name-input" placeholder="プロジェクト名"
                       class="flex-grow bg-gray-700 text-gray-100 rounded-lg px-4 py-2 mr-4 focus:outline-none focus:ring-2 focus:ring-indigo-500 text-xl font-semibold">
                <button id="sort-tasks-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out transform hover:scale-105 mr-2">
                    ソート
                </button>
                <button id="close-task-screen-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold p-2 rounded-full shadow-md transition duration-200 ease-in-out transform hover:scale-110 w-10 h-10 flex items-center justify-center">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>

            <div class="flex-grow overflow-y-auto pr-2">
                <div class="mb-6">
                    <div class="flex justify-between items-center bg-gray-700 px-3 pt-3 rounded-t-lg shadow-inner">
                        <h2 class="text-xl font-semibold text-indigo-300">タスク管理BOX <span id="active-tasks-count" class="text-sm font-medium text-indigo-200 ml-2">0</span></h2>
                        <button id="add-task-btn" class="bg-indigo-500 hover:bg-indigo-600 text-white rounded-full w-8 h-8 flex items-center justify-center shadow-md transition duration-200 ease-in-out transform hover:scale-110">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg>
                        </button>
                    </div>
                    <div id="active-tasks-container" class="bg-gray-700 px-4 pb-4 pt-1 rounded-b-lg min-h-[150px] space-y-3 shadow-lg relative">
                        <p id="no-active-tasks-message" class="text-gray-400 text-center py-4 hidden">アクティブなタスクはありません。</p>
                        <p id="active-drop-message" class="absolute inset-0 flex items-center justify-center text-gray-400 text-lg hidden pointer-events-none">ここにドロップ</p>
                    </div>
                </div>

                <div>
                    <div class="flex justify-between items-center bg-gray-700 px-3 pt-3 rounded-t-lg shadow-inner">
                        <h2 class="text-xl font-semibold text-green-300">完了BOX <span id="completed-tasks-count" class="text-sm font-medium text-green-200 ml-2">0</span></h2>
                    </div>
                    <div id="completed-tasks-container" class="bg-gray-700 px-4 pb-4 pt-1 rounded-b-lg min-h-[100px] space-y-3 shadow-lg relative">
                        <p id="no-completed-tasks-message" class="text-gray-400 text-center py-4 hidden">完了したタスクはありません。</p>
                        <p id="completed-drop-message" class="absolute inset-0 flex items-center justify-center text-gray-400 text-lg hidden pointer-events-none">ここにドロップ</p>
                    </div>
                </div>
            </div>
        </div>

        <div id="priority-picker" class="absolute bg-gray-700 p-2 rounded-lg shadow-xl z-20 hidden flex-wrap gap-2">
            <button class="priority-color-btn w-8 h-8 rounded-full border-2 border-transparent transition duration-150 ease-in-out" data-color="#8b5cf6" style="background-color: #8b5cf6;"></button> <button class="priority-color-btn w-8 h-8 rounded-full border-2 border-transparent transition duration-150 ease-in-out" data-color="#ef4444" style="background-color: #ef4444;"></button> <button class="priority-color-btn w-8 h-8 rounded-full border-2 border-transparent transition duration-150 ease-in-out" data-color="#f97316" style="background-color: #f97316;"></button> <button class="priority-color-btn w-8 h-8 rounded-full border-2 border-transparent transition duration-150 ease-in-out" data-color="#facc15" style="background-color: #facc15;"></button> <button class="priority-color-btn w-8 h-8 rounded-full border-2 border-transparent transition duration-150 ease-in-out" data-color="#22c55e" style="background-color: #22c55e;"></button> <button class="priority-color-btn w-8 h-8 rounded-full border-2 border-transparent transition duration-150 ease-in-out" data-color="#4a5568" style="background-color: #4a5568;"></button> <button class="priority-color-btn w-8 h-8 rounded-full border-2 border-transparent transition duration-150 ease-in-out" data-color="#3b82f6" style="background-color: #3b82f6;"></button> </div>

        <div id="project-context-menu" class="absolute bg-gray-700 p-2 rounded-lg shadow-xl z-20 hidden flex flex-col gap-2">
            <button id="move-project-btn" class="context-menu-btn bg-gray-600 hover:bg-gray-500 text-white px-4 py-2 rounded-lg transition duration-200">入れ替え</button>
            <button id="delete-project-btn" class="context-menu-btn bg-red-600 hover:bg-red-500 text-white px-4 py-2 rounded-lg transition duration-200">削除</button>
            <button id="change-project-color-btn" class="context-menu-btn bg-indigo-600 hover:bg-indigo-500 text-white px-4 py-2 rounded-lg transition duration-200">色変更</button>
        </div>

        <div id="confirm-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden fade-leave-to opacity-0 pointer-events-none">
            <div class="bg-gray-700 p-8 rounded-lg shadow-xl text-center max-w-sm w-full">
                <p id="confirm-message" class="text-lg text-gray-100 mb-6">本当に削除しますか？</p>
                <div class="flex justify-center gap-4">
                    <button id="confirm-yes-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-lg transition duration-200 ease-in-out transform hover:scale-105">はい</button>
                    <button id="confirm-no-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg transition duration-200 ease-in-out transform hover:scale-105">いいえ</button>
                </div>
            </div>
        </div>

        <div id="color-picker-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden fade-leave-to opacity-0 pointer-events-none">
            <div class="bg-gray-700 p-8 rounded-lg shadow-xl text-center max-w-md w-full">
                <h2 class="text-2xl font-bold text-indigo-300 mb-6">プロジェクトアイコンの色を変更</h2>
                <div id="project-color-grid" class="grid grid-cols-4 gap-4 mb-6">
                    </div>
                <button id="close-color-picker-modal-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg transition duration-200 ease-in-out transform hover:scale-105">閉じる</button>
            </div>
        </div>

        <div id="task-context-menu" class="absolute bg-gray-700 p-2 rounded-lg shadow-xl z-20 hidden flex flex-col gap-2">
            <button id="complete-task-btn" class="context-menu-btn font-bold bg-blue-600 hover:bg-blue-500 text-white px-4 py-2 rounded-lg transition duration-200">完了</button>
            <button id="delete-task-btn-menu" class="context-menu-btn font-bold bg-red-600 hover:bg-red-500 text-white px-4 py-2 rounded-lg transition duration-200">削除</button>
        </div>

        <div id="message-box" class="fixed bottom-4 left-1/2 -translate-x-1/2 bg-indigo-600 text-white px-6 py-3 rounded-lg shadow-lg z-50 hidden opacity-0 transition-opacity duration-300">
            メッセージ
        </div>
    </div>

    <script>
        const homeScreen = document.getElementById('home-screen');
        const taskScreen = document.getElementById('task-screen');
        const projectGrid = document.getElementById('project-grid');
        const projectNameInput = document.getElementById('project-name-input');
        const closeTaskScreenBtn = document.getElementById('close-task-screen-btn');
        const addTaskBtn = document.getElementById('add-task-btn');
        const activeTasksContainer = document.getElementById('active-tasks-container');
        const completedTasksContainer = document.getElementById('completed-tasks-container');
        const priorityPicker = document.getElementById('priority-picker');
        const sortTasksBtn = document.getElementById('sort-tasks-btn');
        const projectContextMenu = document.getElementById('project-context-menu');
        const moveProjectBtn = document.getElementById('move-project-btn');
        const deleteProjectBtn = document.getElementById('delete-project-btn');
        const changeProjectColorBtn = document.getElementById('change-project-color-btn');
        const confirmModal = document.getElementById('confirm-modal');
        const confirmMessage = document.getElementById('confirm-message');
        const confirmYesBtn = document.getElementById('confirm-yes-btn');
        const confirmNoBtn = document.getElementById('confirm-no-btn');
        const colorPickerModal = document.getElementById('color-picker-modal');
        const projectColorGrid = document.getElementById('project-color-grid');
        const closeColorPickerModalBtn = document.getElementById('close-color-picker-modal-btn');
        const messageBox = document.getElementById('message-box');
        const appContainer = document.getElementById('app-container');
        const noActiveTasksMessage = document.getElementById('no-active-tasks-message');
        const noCompletedTasksMessage = document.getElementById('no-completed-tasks-message');
        const activeDropMessage = document.getElementById('active-drop-message');
        const completedDropMessage = document.getElementById('completed-drop-message');
        const activeTasksCountSpan = document.getElementById('active-tasks-count');
        const completedTasksCountSpan = document.getElementById('completed-tasks-count');
        const taskContextMenu = document.getElementById('task-context-menu');
        const completeTaskBtn = document.getElementById('complete-task-btn');
        const deleteTaskBtnMenu = document.getElementById('delete-task-btn-menu');
        // ▼▼▼ 追加 ▼▼▼
        const displayToggle = document.getElementById('display-toggle');
        // ▲▲▲ 追加ここまで ▲▲▲

        // Application state
        let projects = [];
        let currentProjectId = null;
        let activeTaskCard = null;
        let activeProjectCell = null;
        let longPressTimer = null;
        let isMovingProjects = false;

        // Constants and state for project display
        // ▼▼▼ 修正 ▼▼▼
        const MAX_PROJECT_CELLS = 24;
        let projectCellCount = MAX_PROJECT_CELLS; // デフォルトは24
        // ▲▲▲ 修正ここまで ▲▲▲

        const PROJECT_ICON_COLORS = [
            '#6366f1', '#a855f7', '#ec4899', '#f43f5e', '#ef4444', '#f97316',
            '#facc15', '#eab308', '#84cc16', '#22c55e', '#06b6d4', '#3b82f6',
            '#8b5cf6', '#dc2626', '#f59e0b', '#10b981', '#0ea5e9', '#6366f1',
            '#7e22ce', '#db2777', '#be123c', '#d97706', '#ca8a04', '#15803d'
        ];

        // Helper functions
        function generateUniqueId() { return crypto.randomUUID(); }

        function updateContainerHeight() {
            const currentScreen = taskScreen.classList.contains('pointer-events-none') ? homeScreen : taskScreen;
            if (currentScreen) {
                const newHeight = currentScreen.scrollHeight;
                appContainer.style.height = `${newHeight}px`;
            }
        }

        function showScreen(screenToShow) {
            projectContextMenu.classList.add('hidden');
            priorityPicker.classList.add('hidden');
            taskContextMenu.classList.add('hidden');
            hideModal(confirmModal);
            hideModal(colorPickerModal);
            const screens = [homeScreen, taskScreen];
            screens.forEach(screen => {
                screen.classList.remove('fade-enter-active', 'fade-enter-to', 'fade-leave-active', 'fade-leave-to');
                screen.classList.add('opacity-0', 'pointer-events-none', 'fade-leave-active');
            });
            setTimeout(() => {
                screenToShow.classList.remove('opacity-0', 'pointer-events-none');
                screenToShow.classList.add('fade-enter-active');
                updateContainerHeight();
                setTimeout(() => {
                    screenToShow.classList.add('fade-enter-to');
                    setTimeout(updateContainerHeight, 300);
                }, 10);
            }, 300);
        }

        function showModal(modalElement) {
            modalElement.classList.remove('hidden', 'fade-leave-to', 'pointer-events-none', 'opacity-0');
            modalElement.classList.add('fade-enter-active', 'fade-enter-to');
        }

        function hideModal(modalElement) {
            modalElement.classList.remove('fade-enter-active', 'fade-enter-to');
            modalElement.classList.add('fade-leave-active', 'fade-leave-to', 'opacity-0');
            setTimeout(() => modalElement.classList.add('hidden', 'pointer-events-none'), 300);
        }

        function showMessage(message, type = 'info', duration = 3000) {
            messageBox.textContent = message;
            messageBox.className = 'fixed bottom-4 left-1/2 -translate-x-1/2 px-6 py-3 rounded-lg shadow-lg z-50 opacity-0 transition-opacity duration-300';
            const bgColor = type === 'error' ? 'bg-red-600' : type === 'success' ? 'bg-green-600' : 'bg-indigo-600';
            messageBox.classList.add(bgColor, 'text-white');
            messageBox.classList.remove('hidden');
            setTimeout(() => messageBox.classList.add('opacity-100'), 10);
            setTimeout(() => {
                messageBox.classList.remove('opacity-100');
                setTimeout(() => messageBox.classList.add('hidden'), 300);
            }, duration);
        }

        // --- Data management ---
        function saveProjects() { localStorage.setItem('taskManagerProjects', JSON.stringify(projects)); }
        
        // ▼▼▼ 修正: 表示数の設定を読み込み、プロジェクトデータの配列長を正規化する ▼▼▼
        function loadProjects() {
            const storedCount = localStorage.getItem('taskManagerDisplayCount');
            projectCellCount = storedCount ? parseInt(storedCount, 10) : MAX_PROJECT_CELLS;
            
            const storedProjects = localStorage.getItem('taskManagerProjects');
            if (storedProjects) {
                projects = JSON.parse(storedProjects);
                if (projects.length < MAX_PROJECT_CELLS) {
                    projects.push(...Array(MAX_PROJECT_CELLS - projects.length).fill(null));
                }
                projects = projects.slice(0, MAX_PROJECT_CELLS);
                projects.forEach(p => p?.tasks.forEach(t => { if (t.originalPriorityColor === undefined) t.originalPriorityColor = null; }));
            } else {
                projects = Array(MAX_PROJECT_CELLS).fill(null);
            }
            renderHome();
        }

        // --- Home screen functions ---
        function renderHome() {
            projectGrid.innerHTML = '';
            // ▼▼▼ 修正: 表示数に合わせてループ ▼▼▼
            for (let i = 0; i < projectCellCount; i++) {
                const project = projects[i];
                const cell = document.createElement('div');
                cell.className = 'project-cell relative w-full aspect-square rounded-xl flex flex-col items-center justify-center cursor-pointer transition duration-200 ease-in-out transform hover:scale-105 shadow-lg p-2';
                cell.dataset.index = i;
                if (project) {
                    cell.style.backgroundColor = project.color;
                    cell.innerHTML = `
                        <div class="flex flex-col items-center justify-center flex-grow">
                            <span class="text-xl font-bold text-white uppercase select-none">${project.iconChar}</span>
                            <span class="text-[10px] font-medium text-white opacity-75 mt-1">${project.name}</span>
                        </div>
                        <div class="absolute bottom-1 left-1 right-1 flex flex-wrap gap-0.5 justify-start max-h-[30px] overflow-hidden p-0.5">
                            ${project.tasks.filter(t => t.status === 'active').map(() => `<div class="w-[10px] h-[10px] bg-white rounded-sm flex-shrink-0"></div>`).join('')}
                        </div>`;
                    cell.dataset.projectId = project.id;
                    cell.draggable = isMovingProjects;
                    if (isMovingProjects) cell.classList.add('highlight');
                } else {
                    cell.className += ' bg-gray-700 hover:bg-gray-600 border-2 border-dashed border-gray-600';
                    cell.innerHTML = `<svg class="w-8 h-8 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg>`;
                }
                projectGrid.appendChild(cell);
            }
            addHomeEventListeners();
        }

        function addHomeEventListeners() {
            document.querySelectorAll('.project-cell').forEach(cell => {
                cell.addEventListener('click', handleProjectCellClick);
                cell.addEventListener('contextmenu', handleProjectCellContextMenu);
                cell.addEventListener('touchstart', handleProjectCellLongPressStart, { passive: true });
                cell.addEventListener('touchend', handleProjectCellLongPressEnd);
                cell.addEventListener('mousedown', handleProjectCellLongPressStart);
                cell.addEventListener('mouseup', handleProjectCellLongPressEnd);
                cell.addEventListener('mouseleave', handleProjectCellLongPressEnd);
                if (isMovingProjects) {
                    cell.addEventListener('dragstart', handleProjectDragStart);
                    cell.addEventListener('dragover', handleProjectDragOver);
                    cell.addEventListener('dragleave', e => e.currentTarget.classList.remove('drag-over'));
                    cell.addEventListener('drop', handleProjectDrop);
                    cell.addEventListener('dragend', handleProjectDragEnd);
                }
            });
        }

        function handleProjectCellClick(event) {
            if (isMovingProjects) return;
            const cell = event.currentTarget;
            const index = parseInt(cell.dataset.index);
            const project = projects[index];
            if (project) {
                openTaskScreen(project.id);
            } else {
                const newProject = { id: generateUniqueId(), name: '', iconChar: '?', color: PROJECT_ICON_COLORS[Math.floor(Math.random() * PROJECT_ICON_COLORS.length)], tasks: [] };
                projects[index] = newProject;
                saveProjects();
                renderHome();
                openTaskScreen(newProject.id);
            }
        }

        function handleProjectCellContextMenu(event) {
            event.preventDefault();
            if (!isMovingProjects && event.currentTarget.dataset.projectId) {
                openProjectContextMenu(event.currentTarget.dataset.projectId, event.currentTarget);
            }
        }

        function handleProjectCellLongPressStart(event) {
            if (isMovingProjects || !event.currentTarget.dataset.projectId) return;
            clearTimeout(longPressTimer);
            const targetElement = event.currentTarget;
            longPressTimer = setTimeout(() => openProjectContextMenu(targetElement.dataset.projectId, targetElement), 300);
        }
        
        function handleProjectCellLongPressEnd() { clearTimeout(longPressTimer); }
        
        function openProjectContextMenu(projectId, targetElement) {
            projectContextMenu.dataset.projectId = projectId;
            projectContextMenu.classList.remove('hidden');
            const targetRect = targetElement.getBoundingClientRect();
            const appRect = appContainer.getBoundingClientRect();
            const numColumns = getComputedStyle(projectGrid).gridTemplateColumns.split(' ').length;
            const isRightmost = (parseInt(targetElement.dataset.index) + 1) % numColumns === 0;
            let menuLeft = isRightmost
                ? targetRect.left - appRect.left - projectContextMenu.offsetWidth - 5
                : targetRect.right - appRect.left + 5;
            projectContextMenu.style.left = `${menuLeft}px`;
            projectContextMenu.style.top = `${targetRect.top - appRect.top}px`;
        }
        
        function handleProjectDragStart(event) {
            const cell = event.currentTarget;
            activeProjectCell = cell;
            event.dataTransfer.setData('text/plain', cell.dataset.projectId);
            event.dataTransfer.effectAllowed = 'move';
            setTimeout(() => cell.classList.add('dragging'), 0);
        }

        function handleProjectDragOver(event) {
            event.preventDefault();
            const targetCell = event.target.closest('.project-cell');
            if (targetCell && targetCell !== activeProjectCell) {
                targetCell.classList.add('drag-over');
            }
        }

        function handleProjectDrop(event) {
            event.preventDefault();
            const targetCell = event.currentTarget;
            targetCell.classList.remove('drag-over');
            const draggedIndex = parseInt(activeProjectCell.dataset.index);
            const targetIndex = parseInt(targetCell.dataset.index);
            if (draggedIndex !== targetIndex) {
                [projects[draggedIndex], projects[targetIndex]] = [projects[targetIndex], projects[draggedIndex]];
                saveProjects();
                renderHome();
                showMessage('プロジェクトを入れ替えました', 'success');
            }
        }

        function handleProjectDragEnd() {
            activeProjectCell?.classList.remove('dragging');
            activeProjectCell = null;
        }

        moveProjectBtn.addEventListener('click', () => {
            isMovingProjects = true;
            projectContextMenu.classList.add('hidden');
            renderHome();
            showMessage('プロジェクトをドラッグ＆ドロップで入れ替えてください', 'info', 5000);
        });

        deleteProjectBtn.addEventListener('click', () => {
            const projectId = projectContextMenu.dataset.projectId;
            projectContextMenu.classList.add('hidden');
            confirmMessage.textContent = '本当にこのプロジェクトを削除しますか？';
            showModal(confirmModal);
            confirmYesBtn.onclick = () => {
                const indexToDelete = projects.findIndex(p => p?.id === projectId);
                if (indexToDelete !== -1) {
                    projects[indexToDelete] = null;
                    saveProjects();
                    renderHome();
                    showMessage('プロジェクトを削除しました', 'success');
                }
                hideModal(confirmModal);
            };
            confirmNoBtn.onclick = () => hideModal(confirmModal);
        });

        changeProjectColorBtn.addEventListener('click', () => {
            const projectId = projectContextMenu.dataset.projectId;
            projectContextMenu.classList.add('hidden');
            showModal(colorPickerModal);
            projectColorGrid.innerHTML = '';
            PROJECT_ICON_COLORS.forEach(color => {
                const button = document.createElement('button');
                button.className = 'w-12 h-12 rounded-full shadow-md transition transform hover:scale-110 border-2 border-transparent';
                button.style.backgroundColor = color;
                button.addEventListener('click', () => {
                    const project = projects.find(p => p?.id === projectId);
                    if (project) {
                        project.color = color;
                        saveProjects();
                        renderHome();
                        showMessage('プロジェクトの色を変更しました', 'success');
                    }
                    hideModal(colorPickerModal);
                });
                projectColorGrid.appendChild(button);
            });
        });
        closeColorPickerModalBtn.addEventListener('click', () => hideModal(colorPickerModal));

        // --- Task Screen functions ---
        function openTaskScreen(projectId) {
            currentProjectId = projectId;
            const project = projects.find(p => p?.id === projectId);
            if (project) {
                projectNameInput.value = project.name;
                renderTasks(project.tasks);
            }
            showScreen(taskScreen);
        }

        closeTaskScreenBtn.addEventListener('click', () => {
            showScreen(homeScreen);
            renderHome();
        });

        projectNameInput.addEventListener('input', (event) => {
            const project = projects.find(p => p?.id === currentProjectId);
            if (project) {
                project.name = event.target.value;
                project.iconChar = event.target.value.at(0) || '?';
                saveProjects();
            }
        });

        function renderTasks(tasks) {
            activeTasksContainer.querySelectorAll('.task-card-wrapper, .mt-4.flex.justify-center').forEach(el => el.remove());
            completedTasksContainer.querySelectorAll('.task-card-wrapper').forEach(el => el.remove());
            const activeTasks = tasks.filter(task => task.status === 'active');
            const completedTasks = tasks.filter(task => task.status === 'completed');
            activeTasksCountSpan.textContent = activeTasks.length;
            completedTasksCountSpan.textContent = completedTasks.length;
            noActiveTasksMessage.classList.toggle('hidden', activeTasks.length > 0);
            activeTasks.forEach(task => activeTasksContainer.appendChild(createTaskCard(task)));
            if (activeTasks.length >= 3) {
                const addButtonContainer = document.createElement('div');
                addButtonContainer.className = 'mt-4 flex justify-center';
                addButtonContainer.innerHTML = `<button id="bottom-add-task-btn" class="bg-indigo-500 hover:bg-indigo-600 text-white rounded-full w-10 h-10 flex items-center justify-center shadow-md transition duration-200 ease-in-out transform hover:scale-110"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg></button>`;
                addButtonContainer.firstElementChild.addEventListener('click', addNewTask);
                activeTasksContainer.appendChild(addButtonContainer);
            }
            noCompletedTasksMessage.classList.toggle('hidden', completedTasks.length > 0);
            completedTasks.forEach(task => completedTasksContainer.appendChild(createTaskCard(task)));
            setTimeout(updateContainerHeight, 50);
        }

        function addNewTask() {
            const project = projects.find(p => p?.id === currentProjectId);
            if (!project) return;
            if (!project.name.trim()) {
                project.name = '新規プロジェクト';
                project.iconChar = '新';
                projectNameInput.value = project.name;
            }
            const newTask = { id: generateUniqueId(), content: '', priorityColor: null, status: 'active', originalPriorityColor: null };
            project.tasks.push(newTask);
            saveProjects();
            renderTasks(project.tasks);
            setTimeout(() => {
                const newCardInput = activeTasksContainer.querySelector(`[data-task-id="${newTask.id}"] .task-content`);
                newCardInput?.focus();
            }, 0);
        }
        addTaskBtn.addEventListener('click', addNewTask);

        function createTaskCard(task) {
            const cardWrapper = document.createElement('div');
            cardWrapper.className = 'task-card-wrapper';
            cardWrapper.dataset.taskId = task.id;
            const card = document.createElement('div');
            card.className = 'task-card relative p-3 rounded-lg shadow-md flex items-center space-x-3 cursor-grab transition duration-200 ease-in-out transform hover:scale-[1.01] active:scale-100';
            card.draggable = true;
            card.dataset.taskId = task.id;
            const originalCardColor = '#4a5568';
            if (task.status === 'completed') {
                card.style.backgroundColor = '#3b82f6';
            } else if (task.priorityColor) {
                card.style.background = `linear-gradient(to right, ${originalCardColor} 50%, ${task.priorityColor} 100%)`;
            } else {
                card.style.backgroundColor = originalCardColor;
            }
            card.innerHTML = `
                <div class="drag-handle w-6 h-full flex items-center justify-center cursor-grab text-gray-300"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg></div>
                <textarea class="task-content flex-grow bg-transparent text-gray-100 placeholder-gray-300 focus:outline-none resize-none overflow-hidden" placeholder="タスク内容" rows="1">${task.content}</textarea>
                <button class="priority-btn w-8 h-8 rounded-full bg-gray-700 flex-shrink-0 flex items-center justify-center shadow-inner transition duration-200 ease-in-out transform hover:scale-110"><i class="fas fa-paint-brush text-gray-300"></i></button>`;
            
            const dragHandle = card.querySelector('.drag-handle');
            dragHandle.addEventListener('contextmenu', (event) => {
                event.preventDefault();
                projectContextMenu.classList.add('hidden');
                priorityPicker.classList.add('hidden');
                openTaskContextMenu(event, task.id, task.status);
            });

            const deleteOverlay = document.createElement('div');
            deleteOverlay.className = 'task-delete-overlay';
            deleteOverlay.innerHTML = `<i class="fas fa-trash-alt text-red-500 mr-2"></i><span>削除</span>`;
            const completeOverlay = document.createElement('div');
            completeOverlay.className = 'task-complete-overlay';
            completeOverlay.innerHTML = `<span>完了</span><i class="fas fa-check text-cyan-500 ml-2"></i>`;
            cardWrapper.append(deleteOverlay, completeOverlay, card);
            const taskContentInput = card.querySelector('.task-content');
            taskContentInput.addEventListener('input', () => {
                taskContentInput.style.height = 'auto';
                taskContentInput.style.height = `${taskContentInput.scrollHeight}px`;
                const project = projects.find(p => p?.id === currentProjectId);
                const taskToUpdate = project?.tasks.find(t => t.id === task.id);
                if (taskToUpdate) {
                    taskToUpdate.content = taskContentInput.value;
                    saveProjects();
                }
                updateContainerHeight();
            });
            setTimeout(() => { taskContentInput.style.height = 'auto'; taskContentInput.style.height = `${taskContentInput.scrollHeight}px`; }, 0);
            card.querySelector('.priority-btn').addEventListener('click', (event) => {
                const cardRect = card.getBoundingClientRect();
                const appRect = appContainer.getBoundingClientRect();
                priorityPicker.classList.remove('hidden');
                priorityPicker.style.top = `${cardRect.bottom - appRect.top + 5}px`;
                priorityPicker.style.left = `${cardRect.right - appRect.left - priorityPicker.offsetWidth}px`;
                priorityPicker.dataset.currentTaskId = task.id;
            });
            let touchStartX = 0;
            let isSwiping = false;
            card.addEventListener('touchstart', e => {
                touchStartX = e.touches[0].clientX;
                isSwiping = false;
                card.style.transition = 'transform 0s';
            }, { passive: true });
            card.addEventListener('touchmove', e => {
                if (activeTaskCard) return;
                const deltaX = e.touches[0].clientX - touchStartX;
                if (Math.abs(deltaX) > 10) isSwiping = true;
                if (isSwiping) {
                    card.style.transform = `translateX(${deltaX}px)`;
                    const swipePercentage = Math.min(1, Math.abs(deltaX) / 100);
                    if (deltaX < 0) {
                        deleteOverlay.style.opacity = swipePercentage;
                        completeOverlay.style.opacity = 0;
                    } else if (task.status === 'active') {
                        completeOverlay.style.opacity = swipePercentage;
                        deleteOverlay.style.opacity = 0;
                    }
                }
            }, { passive: true });
            card.addEventListener('touchend', () => {
                if (!isSwiping) return;
                card.style.transition = 'transform 0.2s ease-out';
                deleteOverlay.style.opacity = 0;
                completeOverlay.style.opacity = 0;
                const endX = parseFloat(card.style.transform.replace('translateX(', '')) || 0;
                if (endX < -200) { 
                    deleteTask(task.id);
                } else if (endX > 100 && task.status === 'active') { 
                    completeTask(task.id);
                } else {
                    card.style.transform = 'translateX(0)';
                }
                isSwiping = false;
            });
            return cardWrapper;
        }

        const handleDragStart = (event) => {
            const card = event.target.closest('.task-card');
            if (card) {
                activeTaskCard = card;
                event.dataTransfer.setData('text/plain', card.dataset.taskId);
                event.dataTransfer.effectAllowed = 'move';
                setTimeout(() => {
                    card.classList.add('dragging');
                    card.closest('.task-card-wrapper').classList.add('wrapper-dragging');
                }, 0);
            }
        };

        const handleDragOver = (event) => {
            event.preventDefault();
            if (!activeTaskCard) return;
            document.querySelectorAll('.drag-over, .drag-over-top, .drag-over-bottom').forEach(el => {
                el.classList.remove('drag-over', 'drag-over-top', 'drag-over-bottom');
            });
            activeDropMessage.classList.add('hidden');
            completedDropMessage.classList.add('hidden');
            const dropTargetCard = event.target.closest('.task-card');
            if (dropTargetCard && dropTargetCard !== activeTaskCard) {
                const targetRect = dropTargetCard.getBoundingClientRect();
                const isTopHalf = event.clientY < targetRect.top + targetRect.height / 2;
                dropTargetCard.classList.add(isTopHalf ? 'drag-over-top' : 'drag-over-bottom');
            } else if (!dropTargetCard) {
                const container = event.currentTarget;
                container.classList.add('drag-over');
                const messageEl = container.id === 'active-tasks-container' ? activeDropMessage : completedDropMessage;
                messageEl.classList.remove('hidden');
            }
        };

        const handleDragLeave = (event) => {
            if (!event.currentTarget.contains(event.relatedTarget)) {
                event.currentTarget.classList.remove('drag-over');
                const messageEl = event.currentTarget.id === 'active-tasks-container' ? activeDropMessage : completedDropMessage;
                messageEl.classList.add('hidden');
            }
        };

        const handleDrop = (event) => {
            event.preventDefault();
            const taskId = event.dataTransfer.getData('text/plain');
            const container = event.currentTarget;
            container.classList.remove('drag-over');
            const messageEl = container.id === 'active-tasks-container' ? activeDropMessage : completedDropMessage;
            messageEl.classList.add('hidden');
            if (!taskId) return;
            const project = projects.find(p => p?.id === currentProjectId);
            if (!project) return;
            const draggedTaskIndex = project.tasks.findIndex(t => t.id === taskId);
            if (draggedTaskIndex === -1) return;
            const [draggedTask] = project.tasks.splice(draggedTaskIndex, 1);
            const newStatus = container.id === 'active-tasks-container' ? 'active' : 'completed';
            if (draggedTask.status !== newStatus) {
                draggedTask.status = newStatus;
                draggedTask.originalPriorityColor = draggedTask.status === 'completed' ? draggedTask.priorityColor : draggedTask.originalPriorityColor;
                draggedTask.priorityColor = newStatus === 'completed' ? '#3b82f6' : draggedTask.originalPriorityColor;
            }
            const dropTargetCard = event.target.closest('.task-card');
            if (dropTargetCard && dropTargetCard !== activeTaskCard) {
                const dropTaskId = dropTargetCard.dataset.taskId;
                let targetIndex = project.tasks.findIndex(t => t.id === dropTaskId);
                const targetRect = dropTargetCard.getBoundingClientRect();
                if (event.clientY >= targetRect.top + targetRect.height / 2) {
                    targetIndex++;
                }
                project.tasks.splice(targetIndex, 0, draggedTask);
            } else {
                if (newStatus === 'active') {
                    const firstCompletedIndex = project.tasks.findIndex(t => t.status === 'completed');
                    project.tasks.splice(firstCompletedIndex === -1 ? project.tasks.length : firstCompletedIndex, 0, draggedTask);
                } else {
                    project.tasks.push(draggedTask);
                }
            }
            saveProjects();
            renderTasks(project.tasks);
            activeTaskCard = null; 
        };

        const handleDragEnd = () => {
            if (activeTaskCard) {
                activeTaskCard.classList.remove('dragging');
                const wrapper = activeTaskCard.closest('.task-card-wrapper');
                if (wrapper) wrapper.classList.remove('wrapper-dragging');
            }
            activeTaskCard = null;
            document.querySelectorAll('.drag-over, .drag-over-top, .drag-over-bottom').forEach(el => {
                el.classList.remove('drag-over', 'drag-over-top', 'drag-over-bottom');
            });
            activeDropMessage.classList.add('hidden');
            completedDropMessage.classList.add('hidden');
        };

        function openTaskContextMenu(event, taskId, taskStatus) {
            taskContextMenu.dataset.taskId = taskId;
            completeTaskBtn.style.display = (taskStatus === 'active') ? 'block' : 'none';
            taskContextMenu.classList.remove('hidden');
            const appRect = appContainer.getBoundingClientRect();
            let menuLeft = event.clientX - appRect.left;
            let menuTop = event.clientY - appRect.top;
            setTimeout(() => {
                if (menuLeft + taskContextMenu.offsetWidth > appRect.width) {
                    menuLeft = appRect.width - taskContextMenu.offsetWidth - 5;
                }
                if (menuTop + taskContextMenu.offsetHeight > appRect.height) {
                    menuTop = appRect.height - taskContextMenu.offsetHeight - 5;
                }
                taskContextMenu.style.left = `${menuLeft}px`;
                taskContextMenu.style.top = `${menuTop}px`;
            }, 0);
        }

        sortTasksBtn.addEventListener('click', () => {
            const project = projects.find(p => p?.id === currentProjectId);
            if (project) {
                const colorOrder = ['#8b5cf6', '#ef4444', '#f97316', '#facc15', '#22c55e', '#3b82f6'];
                project.tasks.sort((a, b) => {
                    const indexA = a.priorityColor ? colorOrder.indexOf(a.priorityColor) : colorOrder.length;
                    const indexB = b.priorityColor ? colorOrder.indexOf(b.priorityColor) : colorOrder.length;
                    return indexA - indexB;
                });
                saveProjects();
                renderTasks(project.tasks);
                showMessage('タスクを色順にソートしました', 'success');
            }
        });

        function deleteTask(taskId) {
            const project = projects.find(p => p?.id === currentProjectId);
            if (project) {
                const taskIndex = project.tasks.findIndex(t => t.id === taskId);
                if (taskIndex > -1) {
                    project.tasks.splice(taskIndex, 1);
                    saveProjects();
                    renderTasks(project.tasks);
                    showMessage('タスクを削除しました', 'success');
                }
            }
        }

        function completeTask(taskId) {
            const project = projects.find(p => p?.id === currentProjectId);
            const task = project?.tasks.find(t => t.id === taskId);
            if (task && task.status === 'active') {
                task.originalPriorityColor = task.priorityColor;
                task.status = 'completed';
                task.priorityColor = '#3b82f6';
                saveProjects();
                renderTasks(project.tasks);
                showMessage('タスクを完了しました！', 'success');
            }
        }

        document.querySelectorAll('.priority-color-btn').forEach(btn => {
            btn.addEventListener('click', (event) => {
                const selectedColor = event.target.dataset.color;
                const taskId = priorityPicker.dataset.currentTaskId;
                const project = projects.find(p => p?.id === currentProjectId);
                const task = project?.tasks.find(t => t.id === taskId);
                if(task){
                    task.priorityColor = selectedColor === '#4a5568' ? null : selectedColor;
                    if(task.status === 'active') task.originalPriorityColor = task.priorityColor;
                    saveProjects();
                    renderTasks(project.tasks);
                }
                priorityPicker.classList.add('hidden');
            });
        });

        completeTaskBtn.addEventListener('click', () => {
            const taskId = taskContextMenu.dataset.taskId;
            if (taskId) {
                completeTask(taskId);
            }
            taskContextMenu.classList.add('hidden');
        });

        deleteTaskBtnMenu.addEventListener('click', () => {
            const taskId = taskContextMenu.dataset.taskId;
            if (taskId) {
                deleteTask(taskId);
            }
            taskContextMenu.classList.add('hidden');
        });

        document.addEventListener('click', (event) => {
            if (!projectContextMenu.contains(event.target) && !event.target.closest('.project-cell')) {
                projectContextMenu.classList.add('hidden');
            }
            if (!priorityPicker.contains(event.target) && !event.target.closest('.priority-btn')) {
                priorityPicker.classList.add('hidden');
            }
            if (!taskContextMenu.contains(event.target) && !event.target.closest('.drag-handle')) {
                taskContextMenu.classList.add('hidden');
            }
            if (isMovingProjects && !event.target.closest('.project-cell') && !event.target.closest('.context-menu-btn')) {
                isMovingProjects = false;
                renderHome();
                showMessage('プロジェクト移動モードを終了しました', 'info');
            }
        });
        
        window.addEventListener('resize', () => {
            updateContainerHeight();
        });
        
        document.addEventListener('DOMContentLoaded', () => {
            loadProjects();
            
            // ▼▼▼ 追加: トグルの初期状態とイベントリスナーを設定 ▼▼▼
            displayToggle.checked = projectCellCount === MAX_PROJECT_CELLS;

            displayToggle.addEventListener('change', () => {
                projectCellCount = displayToggle.checked ? MAX_PROJECT_CELLS : 12;
                localStorage.setItem('taskManagerDisplayCount', projectCellCount);
                renderHome();
                setTimeout(updateContainerHeight, 50); 
            });
            // ▲▲▲ 追加ここまで ▲▲▲

            setTimeout(updateContainerHeight, 50);

            [activeTasksContainer, completedTasksContainer].forEach(container => {
                container.addEventListener('dragstart', handleDragStart);
                container.addEventListener('dragover', handleDragOver);
                container.addEventListener('dragleave', handleDragLeave);
                container.addEventListener('drop', handleDrop);
                container.addEventListener('dragend', handleDragEnd);
            });
        });
    </script>
</body>
</html>
