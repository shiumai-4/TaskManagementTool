<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>タスク管理アプリ</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        /* Custom scrollbar for dark mode */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #2d3748; /* Darker gray */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: #4a5568; /* Medium gray */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280; /* Lighter gray on hover */
        }

        /* Fade transition classes */
        .fade-enter-active, .fade-leave-active {
            transition: opacity 0.3s ease-in-out;
        }
        .fade-enter-from, .fade-leave-to {
            opacity: 0;
        }
        .fade-enter-to, .fade-leave-from {
            opacity: 1;
        }

        /* Custom drag-and-drop styles */
        .dragging {
            opacity: 0.5;
            border: 2px dashed #6366f1; /* Indigo-500 */
        }
        .drag-over {
            /* For containers (active-tasks-container, completed-tasks-container) */
            border: 2px dashed #9ca3af; /* Gray-400 dashed border */
            background-color: #3b4352; /* Slightly lighter dark background for drag over */
        }
        .drag-over-top {
            /* For task cards: indicates insertion before this card */
            border-top: 2px solid #9ca3af; /* Gray-400 solid line */
        }
        .drag-over-bottom {
            /* For task cards: indicates insertion after this card */
            border-bottom: 2px solid #9ca3af; /* Gray-400 solid line */
        }
        .project-cell.drag-over {
            border: 2px dashed #6366f1;
        }
        .project-cell.highlight {
            border: 2px solid #6366f1; /* Highlight for move mode */
        }

        /* Hide specific elements when printing */
        @media print {
            .no-print {
                display: none !important;
            }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen flex flex-col items-center justify-center p-4">

    <!-- Main container -->
    <div id="app-container" class="relative w-full max-w-[500px] bg-gray-800 rounded-xl shadow-2xl p-6 flex flex-col overflow-hidden" style="min-height: 700px;">

        <!-- Home screen -->
        <div id="home-screen" class="absolute inset-0 flex flex-col p-6 fade-enter-active fade-enter-to">
            <h1 class="text-3xl font-bold mb-8 text-center text-indigo-400">プロジェクト</h1>
            <div id="project-grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4 flex-grow overflow-y-auto pb-4">
                <!-- Project cells will be dynamically generated here -->
            </div>
        </div>

        <!-- Task screen -->
        <div id="task-screen" class="absolute inset-0 flex flex-col p-6 bg-gray-800 fade-leave-to opacity-0 pointer-events-none">
            <div class="flex justify-between items-center mb-6">
                <input type="text" id="project-name-input" placeholder="プロジェクト名"
                       class="flex-grow bg-gray-700 text-gray-100 rounded-lg px-4 py-2 mr-4 focus:outline-none focus:ring-2 focus:ring-indigo-500 text-xl font-semibold">
                <button id="sort-tasks-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out transform hover:scale-105 mr-2">
                    ソート
                </button>
                <button id="close-task-screen-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold p-2 rounded-full shadow-md transition duration-200 ease-in-out transform hover:scale-110 w-10 h-10 flex items-center justify-center">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>

            <div class="flex-grow overflow-y-auto pr-2">
                <!-- Task management box -->
                <div class="mb-6">
                    <div class="flex justify-between items-center bg-gray-700 p-3 rounded-t-lg shadow-inner">
                        <h2 class="text-xl font-semibold text-indigo-300">タスク管理</h2>
                        <button id="add-task-btn" class="bg-indigo-500 hover:bg-indigo-600 text-white rounded-full w-8 h-8 flex items-center justify-center shadow-md transition duration-200 ease-in-out transform hover:scale-110">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg>
                        </button>
                    </div>
                    <div id="active-tasks-container" class="bg-gray-700 p-4 rounded-b-lg min-h-[150px] space-y-3 shadow-lg relative">
                        <!-- Active task cards will be dynamically added here -->
                        <p id="active-drop-message" class="absolute inset-0 flex items-center justify-center text-gray-400 text-lg hidden pointer-events-none">ここにドロップ</p>
                    </div>
                    <!-- Moved bottom-add-task-container outside active-tasks-container -->
                    <div id="bottom-add-task-container" class="mt-4 hidden justify-center">
                        <button id="bottom-add-task-btn" class="bg-indigo-500 hover:bg-indigo-600 text-white rounded-full w-10 h-10 flex items-center justify-center shadow-md transition duration-200 ease-in-out transform hover:scale-110">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg>
                        </button>
                    </div>
                </div>

                <!-- Completed box -->
                <div>
                    <h2 class="text-xl font-semibold text-green-300 bg-gray-700 p-3 rounded-t-lg shadow-inner">完了</h2>
                    <div id="completed-tasks-container" class="bg-gray-700 p-4 rounded-b-lg min-h-[100px] space-y-3 shadow-lg relative">
                        <!-- Completed task cards will be dynamically added here -->
                        <p id="completed-drop-message" class="absolute inset-0 flex items-center justify-center text-gray-400 text-lg hidden pointer-events-none">ここにドロップ</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Priority picker window -->
        <div id="priority-picker" class="absolute bg-gray-700 p-2 rounded-lg shadow-xl z-20 hidden flex-wrap gap-2">
            <button class="priority-color-btn w-8 h-8 rounded-full border-2 border-transparent transition duration-150 ease-in-out" data-color="#8b5cf6" style="background-color: #8b5cf6;"></button> <!-- Purple -->
            <button class="priority-color-btn w-8 h-8 rounded-full border-2 border-transparent transition duration-150 ease-in-out" data-color="#ef4444" style="background-color: #ef4444;"></button> <!-- Red -->
            <button class="priority-color-btn w-8 h-8 rounded-full border-2 border-transparent transition duration-150 ease-in-out" data-color="#f97316" style="background-color: #f97316;"></button> <!-- Orange -->
            <button class="priority-color-btn w-8 h-8 rounded-full border-2 border-transparent transition duration-150 ease-in-out" data-color="#facc15" style="background-color: #facc15;"></button> <!-- Yellow -->
            <button class="priority-color-btn w-8 h-8 rounded-full border-2 border-transparent transition duration-150 ease-in-out" data-color="#22c55e" style="background-color: #22c55e;"></button> <!-- Green -->
            <button class="priority-color-btn w-8 h-8 rounded-full border-2 border-transparent transition duration-150 ease-in-out" data-color="#3b82f6" style="background-color: #3b82f6;"></button> <!-- Blue -->
        </div>

        <!-- Project context menu -->
        <div id="project-context-menu" class="absolute bg-gray-700 p-2 rounded-lg shadow-xl z-20 hidden flex-col gap-2">
            <button id="move-project-btn" class="context-menu-btn bg-gray-600 hover:bg-gray-500 text-white px-4 py-2 rounded-lg transition duration-200">入れ替え</button>
            <button id="delete-project-btn" class="context-menu-btn bg-red-600 hover:bg-red-500 text-white px-4 py-2 rounded-lg transition duration-200">削除</button>
            <button id="change-project-color-btn" class="context-menu-btn bg-indigo-600 hover:bg-indigo-500 text-white px-4 py-2 rounded-lg transition duration-200">色変更</button>
        </div>

        <!-- Confirmation modal -->
        <div id="confirm-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden fade-leave-to opacity-0 pointer-events-none">
            <div class="bg-gray-700 p-8 rounded-lg shadow-xl text-center max-w-sm w-full">
                <p id="confirm-message" class="text-lg text-gray-100 mb-6">本当に削除しますか？</p>
                <div class="flex justify-center gap-4">
                    <button id="confirm-yes-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-lg transition duration-200 ease-in-out transform hover:scale-105">はい</button>
                    <button id="confirm-no-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg transition duration-200 ease-in-out transform hover:scale-105">いいえ</button>
                </div>
            </div>
        </div>

        <!-- Color picker modal -->
        <div id="color-picker-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden fade-leave-to opacity-0 pointer-events-none">
            <div class="bg-gray-700 p-8 rounded-lg shadow-xl text-center max-w-md w-full">
                <h2 class="text-2xl font-bold text-indigo-400 mb-6">プロジェクトアイコンの色を変更</h2>
                <div id="project-color-grid" class="grid grid-cols-4 gap-4 mb-6">
                    <!-- Color selection buttons will be dynamically generated here -->
                </div>
                <button id="close-color-picker-modal-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg transition duration-200 ease-in-out transform hover:scale-105">閉じる</button>
            </div>
        </div>

        <!-- Message box -->
        <div id="message-box" class="fixed bottom-4 left-1/2 -translate-x-1/2 bg-indigo-600 text-white px-6 py-3 rounded-lg shadow-lg z-50 hidden opacity-0 transition-opacity duration-300">
            メッセージ
        </div>

    </div>

    <script>
        // Helper functions
        function generateUniqueId() {
            return crypto.randomUUID();
        }

        function showScreen(screenToShow) {
            // Hide menu windows when screen changes
            projectContextMenu.classList.add('hidden');
            priorityPicker.classList.add('hidden');
            hideModal(confirmModal); // Also hide confirmation modal
            hideModal(colorPickerModal); // Also hide color change modal
            hideDropMessages(); // Hide drop messages when screen changes


            const screens = [homeScreen, taskScreen];
            screens.forEach(screen => {
                screen.classList.remove('fade-enter-active', 'fade-enter-to', 'fade-leave-active', 'fade-leave-to');
                screen.classList.add('opacity-0', 'pointer-events-none');
                screen.classList.add('fade-leave-active'); // Start fade out
            });

            // Delay adding fade-enter-active to allow fade-leave-active to start
            setTimeout(() => {
                screenToShow.classList.remove('opacity-0', 'pointer-events-none');
                screenToShow.classList.add('fade-enter-active'); // Start fade in
                setTimeout(() => {
                    screenToShow.classList.remove('fade-enter-from'); // Ensure it reaches full opacity
                    screenToShow.classList.add('fade-enter-to');
                }, 10); // Small delay
            }, 300); // Match transition duration
        }

        function showModal(modalElement) {
            modalElement.classList.remove('hidden', 'fade-leave-to', 'pointer-events-none');
            modalElement.classList.add('fade-enter-active', 'fade-enter-to');
            modalElement.classList.remove('opacity-0');
        }

        function hideModal(modalElement) {
            modalElement.classList.remove('fade-enter-active', 'fade-enter-to');
            modalElement.classList.add('fade-leave-active', 'fade-leave-to');
            modalElement.classList.add('opacity-0');
            setTimeout(() => {
                modalElement.classList.add('hidden', 'pointer-events-none');
            }, 300); // Match transition duration
        }

        function showMessage(message, type = 'info', duration = 3000) {
            messageBox.textContent = message;
            messageBox.className = `fixed bottom-4 left-1/2 -translate-x-1/2 px-6 py-3 rounded-lg shadow-lg z-50 opacity-0 transition-opacity duration-300`;

            let bgColor = 'bg-indigo-600';
            if (type === 'error') bgColor = 'bg-red-600';
            if (type === 'success') bgColor = 'bg-green-600';

            messageBox.classList.add(bgColor, 'text-white');
            messageBox.classList.remove('hidden');

            setTimeout(() => {
                messageBox.classList.add('opacity-100');
            }, 10);

            setTimeout(() => {
                messageBox.classList.remove('opacity-100');
                setTimeout(() => {
                    messageBox.classList.add('hidden');
                }, 300);
            }, duration);
        }

        // Functions to show/hide drop messages
        function showDropMessage(containerId) {
            if (containerId === 'active-tasks-container') {
                activeDropMessage.classList.remove('hidden');
            } else if (containerId === 'completed-tasks-container') {
                completedDropMessage.classList.remove('hidden');
            }
        }

        function hideDropMessages() {
            activeDropMessage.classList.add('hidden');
            completedDropMessage.classList.add('hidden');
        }

        function openTaskScreen(projectId) {
            currentProjectId = projectId;
            const project = projects.find(p => p && p.id === projectId);
            if (project) {
                projectNameInput.value = project.name;
                projectNameInput.dataset.projectId = projectId; // Store project ID on input
                renderTasks(project.tasks);
            }
            showScreen(taskScreen);
        }

        function renderTasks(tasks) {
            console.log("--- renderTasks called for project:", currentProjectId, "---"); // Debug log
            const currentProject = projects.find(p => p && p.id === currentProjectId);
            if (currentProject) {
                console.log("Current project tasks state BEFORE rendering:", JSON.parse(JSON.stringify(currentProject.tasks))); // Debug log
            }

            activeTasksContainer.innerHTML = '';
            completedTasksContainer.innerHTML = '';

            const activeTasks = tasks.filter(task => task.status === 'active');
            const completedTasks = tasks.filter(task => task.status === 'completed');

            console.log("Active tasks to render:", JSON.parse(JSON.stringify(activeTasks))); // Debug log
            console.log("Completed tasks to render:", JSON.parse(JSON.stringify(completedTasks))); // Debug log

            if (activeTasks.length === 0) {
                activeTasksContainer.innerHTML = '<p class="text-gray-400 text-center py-4">アクティブなタスクはありません。</p>';
            } else {
                activeTasks.forEach(task => activeTasksContainer.appendChild(createTaskCard(task)));
            }

            // Show bottom add button if 3 or more tasks
            if (activeTasks.length >= 3) {
                bottomAddTaskContainer.classList.remove('hidden');
                bottomAddTaskContainer.classList.add('flex'); // Add flex to enable centering
            } else {
                bottomAddTaskContainer.classList.add('hidden');
                bottomAddTaskContainer.classList.remove('flex');
            }
            // bottomAddTaskContainer is now outside activeTasksContainer, so no need to append it here.


            if (completedTasks.length === 0) {
                completedTasksContainer.innerHTML = '<p class="text-gray-400 text-center py-4">完了したタスクはありません。</p>';
            } else {
                completedTasks.forEach(task => completedTasksContainer.appendChild(createTaskCard(task)));
            }
            console.log("--- renderTasks finished ---"); // Debug log
        }

        function createTaskCard(task) {
            const card = document.createElement('div');
            // Removed bg-gray-600 class to allow custom background style
            card.classList.add('task-card', 'relative', 'p-3', 'rounded-lg', 'shadow-md', 'flex', 'items-center', 'space-x-3', 'cursor-grab', 'transition', 'duration-200', 'ease-in-out', 'transform', 'hover:scale-[1.01]', 'active:scale-100');
            card.draggable = true;
            card.dataset.taskId = task.id;
            card.dataset.status = task.status; // Store status for drag/swipe logic

            const originalCardColor = '#4a5568'; // Equivalent to Tailwind's bg-gray-600

            if (task.status === 'completed') {
                // Completed tasks are solid blue
                card.style.backgroundColor = '#3b82f6'; // Tailwind's blue-500
            } else if (task.priorityColor) {
                // Active tasks with priority: apply gradient
                const priorityHex = task.priorityColor;
                card.style.background = `linear-gradient(to right, ${originalCardColor} 0%, ${originalCardColor} 50%, ${priorityHex} 75%, ${priorityHex} 100%)`;
            } else {
                // Active tasks without priority: apply original gray color
                card.style.backgroundColor = originalCardColor;
            }

            card.innerHTML = `
                <!-- Drag handle area -->
                <div class="drag-handle w-6 h-full flex items-center justify-center cursor-grab text-gray-300">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
                </div>
                <!-- Task content input area -->
                <textarea class="task-content flex-grow bg-transparent text-gray-100 placeholder-gray-300 focus:outline-none resize-none overflow-hidden"
                          placeholder="タスク内容" rows="1">${task.content}</textarea>
                <!-- Priority button -->
                <button class="priority-btn w-8 h-8 rounded-full bg-gray-700 flex-shrink-0 flex items-center justify-center shadow-inner transition duration-200 ease-in-out transform hover:scale-110">
                    <svg class="w-5 h-5 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 12h14M12 5l7 7-7 7"></path></svg>
                </button>
            `;

            const taskContentInput = card.querySelector('.task-content');
            const priorityBtn = card.querySelector('.priority-btn');

            // Adjust textarea height dynamically
            taskContentInput.addEventListener('input', () => {
                taskContentInput.style.height = 'auto';
                taskContentInput.style.height = (taskContentInput.scrollHeight) + 'px';
            });
            // Initial height adjustment
            setTimeout(() => {
                taskContentInput.style.height = 'auto';
                taskContentInput.style.height = (taskContentInput.scrollHeight) + 'px';
            }, 0);


            // Update task content
            taskContentInput.addEventListener('input', (event) => {
                const project = projects.find(p => p && p.id === currentProjectId);
                if (project) {
                    const taskToUpdate = project.tasks.find(t => t.id === task.id);
                    if (taskToUpdate) {
                        taskToUpdate.content = event.target.value;
                        saveProjects();
                    }
                }
            });

            // Priority button click event
            priorityBtn.addEventListener('click', (event) => {
                const btnRect = priorityBtn.getBoundingClientRect();
                const appContainerRect = appContainer.getBoundingClientRect();

                // Temporarily show to get dimensions, then hide
                priorityPicker.style.visibility = 'hidden';
                priorityPicker.classList.remove('hidden');
                // Reset transform for accurate offsetWidth/Height
                priorityPicker.style.transform = 'none'; 
                const pickerWidth = priorityPicker.offsetWidth;
                const pickerHeight = priorityPicker.offsetHeight;
                priorityPicker.classList.add('hidden');
                priorityPicker.style.visibility = 'visible';

                // Desired initial position: centered horizontally relative to button, below button
                let pickerLeft = btnRect.left + (btnRect.width / 2) - (pickerWidth / 2); // Calculate true left for centering
                let pickerTop = btnRect.bottom + MENU_OFFSET;
                
                // Check for horizontal overflow and adjust
                if (pickerLeft < appContainerRect.left + MENU_OFFSET) {
                    pickerLeft = appContainerRect.left + MENU_OFFSET; // Align to left edge of app container
                } else if ((pickerLeft + pickerWidth) > (appContainerRect.right - MENU_OFFSET)) {
                    pickerLeft = appContainerRect.right - pickerWidth - MENU_OFFSET; // Align to right edge of app container
                }

                // Check for vertical overflow and adjust
                if (pickerTop + pickerHeight > appContainerRect.bottom) {
                    // Overflows bottom, try to place it above the button
                    pickerTop = btnRect.top - pickerHeight - MENU_OFFSET;
                    // Ensure it doesn't go off the top edge of the app container
                    if (pickerTop < appContainerRect.top) {
                        pickerTop = appContainerRect.top + MENU_OFFSET; // Fallback: place at top edge with padding
                    }
                }

                priorityPicker.style.left = `${pickerLeft}px`;
                priorityPicker.style.top = `${pickerTop}px`;
                priorityPicker.style.transform = 'none'; // Keep transform as none since we calculated absolute position
                priorityPicker.classList.remove('hidden');
                priorityPicker.dataset.currentTaskId = task.id; // Store task ID for color selection

                // Highlight currently selected color
                document.querySelectorAll('.priority-color-btn').forEach(btn => {
                    btn.classList.remove('border-blue-400'); // Remove previous highlight
                    if (btn.dataset.color === task.priorityColor) {
                        btn.classList.add('border-blue-400'); // Add highlight
                    }
                });
            });

            // Variables for touch events
            let touchStartX = 0;
            let touchStartY = 0;
            let isSwiping = false;

            card.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                    isSwiping = false;
                    card.style.transition = 'none'; // Disable transition during swipe
                }
            }, { passive: true });

            card.addEventListener('touchmove', (e) => {
                if (e.touches.length === 1 && task.status === 'active') {
                    const touchCurrentX = e.touches[0].clientX;
                    const deltaX = touchCurrentX - touchStartX;
                    const deltaY = e.touches[0].clientY - touchStartY;

                    // Determine if it's primarily a horizontal swipe
                    if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 10) { // Threshold for swipe
                        isSwiping = true;
                        card.style.transform = `translateX(${deltaX}px)`;
                    } else {
                        isSwiping = false;
                    }
                }
            }, { passive: true });

            card.addEventListener('touchend', () => {
                card.style.transition = 'transform 0.2s ease-out'; // Re-enable transition
                if (isSwiping && task.status === 'active') {
                    const currentTransform = card.style.transform;
                    const translateXMatch = currentTransform.match(/translateX\(([^)]+)px\)/);
                    const currentX = translateXMatch ? parseFloat(translateXMatch[1]) : 0;

                    if (currentX < -100) { // Swipe left threshold
                        completeTask(task.id);
                        card.style.transform = 'translateX(-100vw)'; // Animate off screen
                        setTimeout(() => {
                            card.remove(); // Remove after animation
                            renderTasks(projects.find(p => p && p.id === currentProjectId).tasks); // Re-render to update containers
                        }, 200);
                    } else {
                        card.style.transform = 'translateX(0)'; // Snap back
                    }
                }
                isSwiping = false;
            });

            // Drag event listeners
            card.addEventListener('dragstart', handleTaskDragStart);
            card.addEventListener('dragover', handleTaskDragOver);
            card.addEventListener('dragleave', handleTaskDragLeave);
            card.addEventListener('drop', handleTaskDrop);
            card.addEventListener('dragend', handleTaskDragEnd);

            return card;
        }

        // Global DOM element references (declared globally, initialized in DOMContentLoaded)
        let homeScreen;
        let taskScreen;
        let projectGrid;
        let projectNameInput;
        let closeTaskScreenBtn;
        let addTaskBtn;
        let activeTasksContainer;
        let completedTasksContainer;
        let priorityPicker;
        let sortTasksBtn;
        let projectContextMenu;
        let moveProjectBtn;
        let deleteProjectBtn;
        let changeProjectColorBtn;
        let confirmModal;
        let confirmMessage;
        let confirmYesBtn;
        let confirmNoBtn;
        let colorPickerModal;
        let projectColorGrid;
        let closeColorPickerModalBtn;
        let messageBox;
        let appContainer;
        let bottomAddTaskContainer;
        let bottomAddTaskBtn;
        let activeDropMessage;
        let completedDropMessage;

        // Application state (declared globally)
        let projects = [];
        let currentProjectId = null;
        let activeTaskCard = null; // Dragged task card
        let activeProjectCell = null; // Dragged project cell
        let longPressTimer = null;
        let isMovingProjects = false; // Project move mode flag

        // Constants (declared globally)
        const NUM_PROJECT_CELLS = 12;
        const MENU_OFFSET = 5; // New constant for menu/picker offset
        const PRIORITY_COLORS = {
            '#8b5cf6': 'bg-purple-400', // Purple (slightly lighter)
            '#ef4444': 'bg-red-400',    // Red (slightly lighter)
            '#f97316': 'bg-orange-400', // Orange (slightly lighter)
            '#facc15': 'bg-yellow-400', // Yellow (slightly lighter)
            '#22c55e': 'bg-green-400',  // Green (slightly lighter)
            '#3b82f6': 'bg-blue-400'    // Blue (slightly lighter)
        };
        const PROJECT_ICON_COLORS = [
            '#6366f1', '#a855f7', '#ec4899', '#f43f5e', '#ef4444', '#f97316',
            '#facc15', '#eab308', '#84cc16', '#22c55e', '#06b6d4', '#3b82f6'
        ]; // Tailwind indigo-500, purple-500, pink-500, rose-500, red-500, orange-500, yellow-500, amber-500, lime-500, green-500, cyan-500, blue-500

        // --- Data management ---
        function saveProjects() {
            localStorage.setItem('taskManagerProjects', JSON.stringify(projects));
            console.log("Projects saved:", JSON.parse(JSON.stringify(projects))); // Debug log
        }

        function loadProjects() {
            const storedProjects = localStorage.getItem('taskManagerProjects');
            if (storedProjects) {
                projects = JSON.parse(storedProjects);
                // Ensure all tasks have originalPriorityColor property for backward compatibility
                projects.forEach(project => {
                    if (project && project.tasks) {
                        project.tasks.forEach(task => {
                            if (task.originalPriorityColor === undefined) {
                                task.originalPriorityColor = null; // Initialize if missing
                            }
                        });
                    }
                });
                console.log("Projects loaded:", JSON.parse(JSON.stringify(projects))); // Debug log
            } else {
                // Initialize with empty cells if no data
                projects = Array(NUM_PROJECT_CELLS).fill(null);
                console.log("Projects initialized (empty):", JSON.parse(JSON.stringify(projects))); // Debug log
            }
            renderHome();
        }

        // --- Home screen rendering ---
        function renderHome() {
            projectGrid.innerHTML = '';
            for (let i = 0; i < NUM_PROJECT_CELLS; i++) {
                const project = projects[i];
                const cell = document.createElement('div');
                // Added p-2 to project-cell for internal padding
                // Added max-w-[100px] and max-h-[100px] for max size
                cell.classList.add('project-cell', 'relative', 'w-full', 'aspect-square', 'rounded-xl', 'flex', 'flex-col', 'items-center', 'justify-center', 'cursor-pointer', 'transition', 'duration-200', 'ease-in-out', 'transform', 'hover:scale-105', 'shadow-lg', 'p-2', 'max-w-[100px]', 'max-h-[100px]');
                cell.dataset.index = i; // Store index for drag and drop

                if (project) {
                    cell.classList.add('bg-gray-700', 'hover:bg-gray-600');
                    cell.style.backgroundColor = project.color; // Apply project specific color

                    // Project name and icon character
                    const projectContent = document.createElement('div');
                    // Changed icon character size to text-3xl
                    projectContent.classList.add('flex', 'flex-col', 'items-center', 'justify-center', 'flex-grow');
                    projectContent.innerHTML = `
                        <span class="text-3xl font-bold text-white uppercase select-none">${project.iconChar}</span>
                        <span class="text-xs font-medium text-white opacity-75 mt-1">${project.name}</span>
                    `;
                    cell.appendChild(projectContent);

                    // Task count squares container
                    const taskSquaresContainer = document.createElement('div');
                    // Changed bottom-2 to bottom-1, adjusted gap and padding
                    taskSquaresContainer.classList.add('absolute', 'bottom-1', 'left-1', 'right-1', 'flex', 'flex-wrap', 'gap-0.5', 'justify-start', 'max-h-[40px]', 'overflow-hidden', 'p-0.5'); // gap and padding adjusted

                    // Add squares for each task
                    const activeTasksCount = project.tasks.filter(t => t.status === 'active').length;
                    for (let j = 0; j < activeTasksCount; j++) {
                        const square = document.createElement('div');
                        square.classList.add('w-[15px]', 'h-[15px]', 'bg-white', 'rounded-sm', 'flex-shrink-0');
                        taskSquaresContainer.appendChild(square);
                    }
                    cell.appendChild(taskSquaresContainer);

                    cell.dataset.projectId = project.id;
                    cell.draggable = isMovingProjects; // Make draggable only in move mode
                    if (isMovingProjects) {
                        cell.classList.add('highlight');
                    }
                } else {
                    cell.classList.add('bg-gray-700', 'hover:bg-gray-600', 'border-2', 'border-dashed', 'border-gray-600');
                    cell.innerHTML = `
                        <svg class="w-12 h-12 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg>
                    `;
                }

                projectGrid.appendChild(cell);
            }
            addHomeEventListeners();
        }

        function addHomeEventListeners() {
            document.querySelectorAll('.project-cell').forEach(cell => {
                // Remove existing listeners to prevent duplicates
                cell.removeEventListener('click', handleProjectCellClick);
                cell.removeEventListener('touchstart', handleProjectCellLongPressStart);
                cell.removeEventListener('touchend', handleProjectCellLongPressEnd);
                cell.removeEventListener('touchcancel', handleProjectCellLongPressEnd);
                cell.removeEventListener('mousedown', handleProjectCellLongPressStart);
                cell.removeEventListener('mouseup', handleProjectCellLongPressEnd);
                cell.removeEventListener('mouseleave', handleProjectCellLongPressEnd);

                // Add new listeners
                cell.addEventListener('click', handleProjectCellClick);
                cell.addEventListener('touchstart', handleProjectCellLongPressStart, { passive: true });
                cell.addEventListener('touchend', handleProjectCellLongPressEnd);
                cell.addEventListener('touchcancel', handleProjectCellLongPressEnd);
                cell.addEventListener('mousedown', handleProjectCellLongPressStart);
                cell.addEventListener('mouseup', handleProjectCellLongPressEnd);
                cell.addEventListener('mouseleave', handleProjectCellLongPressEnd);

                // Drag and drop for project cells (only if moving projects)
                if (isMovingProjects) {
                    cell.addEventListener('dragstart', handleProjectDragStart);
                    cell.addEventListener('dragover', handleProjectDragOver);
                    cell.addEventListener('dragleave', handleProjectDragLeave);
                    cell.addEventListener('drop', handleProjectDrop);
                    cell.addEventListener('dragend', handleProjectDragEnd);
                } else {
                    // Ensure drag attributes are removed if not in move mode
                    cell.removeAttribute('draggable');
                    cell.classList.remove('highlight');
                }
            });
        }

        function handleProjectCellClick(event) {
            const cell = event.currentTarget;
            const projectId = cell.dataset.projectId;

            if (isMovingProjects) {
                // In move mode, clicking should not open task screen
                return;
            }

            if (projectId) {
                openTaskScreen(projectId);
            } else {
                // Empty cell clicked, create a new project
                const newProjectId = generateUniqueId();
                const newProject = {
                    id: newProjectId,
                    name: '',
                    iconChar: '?',
                    color: PROJECT_ICON_COLORS[Math.floor(Math.random() * PROJECT_ICON_COLORS.length)],
                    tasks: []
                };
                const cellIndex = parseInt(cell.dataset.index);
                projects[cellIndex] = newProject;
                saveProjects();
                renderHome(); // Re-render to show new empty project
                openTaskScreen(newProjectId);
            }
        }

        function handleProjectCellLongPressStart(event) {
            // Do not open menu if in project move mode
            if (isMovingProjects) {
                clearTimeout(longPressTimer); // Clear existing timer
                return;
            }

            const cell = event.currentTarget;
            const projectId = cell.dataset.projectId;
            if (!projectId) return; // Only for existing projects

            clearTimeout(longPressTimer);
            longPressTimer = setTimeout(() => {
                // Pass the cell element directly instead of the event object
                openProjectContextMenu(projectId, cell);
            }, 800); // 0.8 second long press
        }

        function handleProjectCellLongPressEnd() {
            clearTimeout(longPressTimer);
        }

        // Modified to accept cellElement directly
        function openProjectContextMenu(projectId, cellElement) {
            const project = projects.find(p => p && p.id === projectId);
            if (!project) return;

            projectContextMenu.dataset.projectId = projectId;

            const cellRect = cellElement.getBoundingClientRect();
            const appContainerRect = appContainer.getBoundingClientRect();

            // Temporarily show to get dimensions, then hide
            projectContextMenu.style.visibility = 'hidden';
            projectContextMenu.classList.remove('hidden');
            const menuWidth = projectContextMenu.offsetWidth;
            const menuHeight = projectContextMenu.offsetHeight;
            projectContextMenu.classList.add('hidden');
            projectContextMenu.style.visibility = 'visible';

            // Desired initial position: to the right of the cell
            let menuLeft = cellRect.right + MENU_OFFSET; // Use MENU_OFFSET
            let menuTop = cellRect.top;

            // Check for horizontal overflow
            if (menuLeft + menuWidth > appContainerRect.right) {
                // If it overflows right, try to place it to the left of the cell
                menuLeft = cellRect.left - menuWidth - MENU_OFFSET; // Use MENU_OFFSET
                // Ensure it doesn't go off the left edge of the app container
                if (menuLeft < appContainerRect.left) {
                    menuLeft = appContainerRect.left + MENU_OFFSET; // Fallback: place at left edge with padding
                }
            }

            // Check for vertical overflow
            if (menuTop + menuHeight > appContainerRect.bottom) {
                // If it overflows bottom, try to place it above the cell
                menuTop = cellRect.top - menuHeight - MENU_OFFSET; // Adjusted for consistent offset when placing above
                // Ensure it doesn't go off the top edge of the app container
                if (menuTop < appContainerRect.top) {
                    menuTop = appContainerRect.top + MENU_OFFSET; // Fallback: place at top edge with padding
                }
            }

            projectContextMenu.style.left = `${menuLeft}px`;
            projectContextMenu.style.top = `${menuTop}px`;
            projectContextMenu.classList.remove('hidden');
        }

        // --- Project move mode ---
        function handleProjectDragStart(event) {
            const cell = event.currentTarget;
            activeProjectCell = cell;
            event.dataTransfer.setData('text/plain', cell.dataset.projectId);
            event.dataTransfer.effectAllowed = 'move';
            setTimeout(() => cell.classList.add('dragging'), 0);
        }

        function handleProjectDragOver(event) {
            event.preventDefault(); // Allow drop
            event.dataTransfer.dropEffect = 'move';

            // Remove all drag-over classes from all potential targets first
            document.querySelectorAll('.task-card, #active-tasks-container, #completed-tasks-container').forEach(el => {
                el.classList.remove('drag-over', 'drag-over-top', 'drag-over-bottom');
            });
            hideDropMessages(); // Hide drop messages from previous targets

            const target = event.target.closest('.task-card, #active-tasks-container, #completed-tasks-container');

            if (target && target !== activeTaskCard) {
                if (target.classList.contains('task-card')) {
                    // Hovering over another task card
                    const targetRect = target.getBoundingClientRect();
                    const targetMiddleY = targetRect.top + targetRect.height / 2;
                    const isBefore = event.clientY < targetMiddleY;

                    if (isBefore) {
                        target.classList.add('drag-over-top');
                    } else {
                        target.classList.add('drag-over-bottom');
                    }
                } else if (target.id === 'active-tasks-container' || target.id === 'completed-tasks-container') {
                    // Hovering over an empty container or container itself
                    target.classList.add('drag-over');
                    // Check if the container is actually empty of *task cards*
                    const hasTaskCards = target.querySelector('.task-card');
                    if (!hasTaskCards) { // Only show message if truly empty of cards
                        showDropMessage(target.id);
                    }
                }
            }
        }

        function handleProjectDragLeave(event) {
            const target = event.currentTarget;
            target.classList.remove('drag-over', 'drag-over-top', 'drag-over-bottom');
            // If leaving a container, ensure its specific drag-over class is removed
            if (target.id === 'active-tasks-container' || target.id === 'completed-tasks-container') {
                target.classList.remove('drag-over');
                hideDropMessages(); // Hide messages when dragging out of a container
            }
        }

        function handleTaskDrop(event) {
            event.preventDefault();
            const taskId = event.dataTransfer.getData('text/plain');
            const draggedCard = document.querySelector(`[data-task-id="${taskId}"]`);
            const target = event.target.closest('.task-card, #active-tasks-container, #completed-tasks-container');

            if (!draggedCard || !target) return;

            const project = projects.find(p => p && p.id === currentProjectId);
            if (!project) return;

            // Remove all drag-over classes from all elements after drop
            document.querySelectorAll('.task-card, #active-tasks-container, #completed-tasks-container').forEach(el => {
                el.classList.remove('drag-over', 'drag-over-top', 'drag-over-bottom');
            });
            hideDropMessages(); // Hide messages after drop

            const draggedTask = project.tasks.find(t => t.id === taskId);
            if (!draggedTask) return;

            let newStatus = draggedTask.status; // Default to current status
            let targetContainer = null;

            if (target.id === 'active-tasks-container') {
                targetContainer = activeTasksContainer;
                newStatus = 'active';
            } else if (target.id === 'completed-tasks-container') {
                targetContainer = completedTasksContainer;
                newStatus = 'completed';
            } else if (target.classList.contains('task-card')) {
                // Dropped onto another task card
                targetContainer = target.closest('#active-tasks-container') || target.closest('#completed-tasks-container');
                newStatus = targetContainer.id === 'active-tasks-container' ? 'active' : 'completed';
            }

            if (targetContainer) {
                // Update task status if it changed containers
                if (draggedTask.status !== newStatus) {
                    if (newStatus === 'completed') {
                        // Moving to completed: store current color, then set to blue
                        draggedTask.originalPriorityColor = draggedTask.priorityColor;
                        draggedTask.priorityColor = '#3b82f6';
                    } else if (newStatus === 'active') {
                        // Moving to active: restore original color
                        draggedTask.priorityColor = draggedTask.originalPriorityColor;
                        draggedTask.originalPriorityColor = null; // Clear stored original color
                    }
                    draggedTask.status = newStatus; // Update status last
                }

                // Reorder tasks within the project.tasks array
                const currentTasksInContainer = project.tasks.filter(t => t.id !== draggedTask.id && t.status === newStatus); // Exclude dragged task from current list
                const otherTasks = project.tasks.filter(t => t.id !== draggedTask.id && t.status !== newStatus); // Exclude dragged task from other lists

                let insertIndex = currentTasksInContainer.length; // Default to end of container

                if (target.classList.contains('task-card')) {
                    const targetTaskId = target.dataset.taskId;
                    const targetIndex = currentTasksInContainer.findIndex(t => t.id === targetTaskId);

                    if (targetIndex > -1) {
                        const targetRect = target.getBoundingClientRect();
                        const isBefore = event.clientY < (targetRect.top + targetRect.height / 2);
                        insertIndex = isBefore ? targetIndex : targetIndex + 1;
                    }
                }
                
                currentTasksInContainer.splice(insertIndex, 0, draggedTask); // Insert dragged task

                project.tasks = [...otherTasks, ...currentTasksInContainer];
                saveProjects();
                renderTasks(project.tasks);
            }
        }

        function handleTaskDragEnd(event) {
            activeTaskCard.classList.remove('dragging');
            activeTaskCard = null;
            // Remove any lingering drag-over classes
            document.querySelectorAll('.task-card, #active-tasks-container, #completed-tasks-container').forEach(el => {
                el.classList.remove('drag-over', 'drag-over-top', 'drag-over-bottom');
            });
            hideDropMessages(); // Hide messages when drag ends
        }

        // --- Complete task (swipe left) ---
        function completeTask(taskId) {
            const project = projects.find(p => p && p.id === currentProjectId);
            if (project) {
                const taskToComplete = project.tasks.find(t => t.id === taskId);
                if (taskToComplete && taskToComplete.status === 'active') {
                    // Store original color before changing to completed blue
                    taskToComplete.originalPriorityColor = taskToComplete.priorityColor;
                    taskToComplete.status = 'completed';
                    taskToComplete.priorityColor = '#3b82f6'; // Blue when completed
                    saveProjects();
                    showMessage('タスクを完了しました！', 'success');
                }
            }
        }

        // Global click handler: handles hiding context menus, priority pickers, and exiting project move mode
        document.addEventListener('click', (event) => {
            // Hide project context menu
            if (!projectContextMenu.classList.contains('hidden') && !projectContextMenu.contains(event.target) && !event.target.closest('.project-cell')) {
                projectContextMenu.classList.add('hidden');
            }

            // Hide priority picker
            if (!priorityPicker.classList.contains('hidden') && !priorityPicker.contains(event.target) && !event.target.closest('.priority-btn')) {
                priorityPicker.classList.add('hidden');
            }

            // Exit project move mode
            if (isMovingProjects) {
                const clickedProjectCell = event.target.closest('.project-cell');
                const clickedContextMenuButton = event.target.closest('.context-menu-btn'); // Check if a context menu button was clicked

                // If clicked element is neither a project cell nor a context menu button, exit move mode
                if (!clickedProjectCell && !clickedContextMenuButton) {
                    isMovingProjects = false;
                    renderHome();
                    showMessage('プロジェクト移動モードを終了しました', 'info');
                }
            }
        });


        // Initial load
        document.addEventListener('DOMContentLoaded', () => {
            // DOM element references - moved inside DOMContentLoaded
            homeScreen = document.getElementById('home-screen');
            taskScreen = document.getElementById('task-screen');
            projectGrid = document.getElementById('project-grid');
            projectNameInput = document.getElementById('project-name-input');
            closeTaskScreenBtn = document.getElementById('close-task-screen-btn');
            addTaskBtn = document.getElementById('add-task-btn'); // Top-right plus button
            activeTasksContainer = document.getElementById('active-tasks-container');
            completedTasksContainer = document.getElementById('completed-tasks-container');
            priorityPicker = document.getElementById('priority-picker');
            sortTasksBtn = document.getElementById('sort-tasks-btn');
            projectContextMenu = document.getElementById('project-context-menu');
            moveProjectBtn = document.getElementById('move-project-btn');
            deleteProjectBtn = document.getElementById('delete-project-btn');
            changeProjectColorBtn = document.getElementById('change-project-color-btn');
            confirmModal = document.getElementById('confirm-modal');
            confirmMessage = document.getElementById('confirm-message');
            confirmYesBtn = document.getElementById('confirm-yes-btn');
            confirmNoBtn = document.getElementById('confirm-no-btn');
            colorPickerModal = document.getElementById('color-picker-modal');
            projectColorGrid = document.getElementById('project-color-grid');
            closeColorPickerModalBtn = document.getElementById('close-color-picker-modal-btn');
            messageBox = document.getElementById('message-box');
            appContainer = document.getElementById('app-container');
            bottomAddTaskContainer = document.getElementById('bottom-add-task-container');
            bottomAddTaskBtn = document.getElementById('bottom-add-task-btn');
            activeDropMessage = document.getElementById('active-drop-message');
            completedDropMessage = document.getElementById('completed-drop-message');

            loadProjects(); // Initial load of projects

            // Event Listeners - moved inside DOMContentLoaded
            closeTaskScreenBtn.addEventListener('click', () => {
                currentProjectId = null;
                showScreen(homeScreen);
                renderHome(); // Call renderHome to update task counts on project icons
            });

            projectNameInput.addEventListener('input', (event) => {
                const projectId = event.target.dataset.projectId;
                const project = projects.find(p => p && p.id === projectId);
                if (project) {
                    project.name = event.target.value;
                    project.iconChar = event.target.value.charAt(0).toUpperCase() || '?';
                    saveProjects();
                    renderHome(); // Update icon on home screen
                }
            });

            addTaskBtn.addEventListener('click', () => {
                const project = projects.find(p => p && p.id === currentProjectId);
                if (!project) return;

                if (!project.name.trim()) {
                    project.name = '新規プロジェクト';
                    project.iconChar = '新';
                    projectNameInput.value = project.name;
                    saveProjects();
                    renderHome();
                }

                const newTask = {
                    id: generateUniqueId(),
                    content: '',
                    priorityColor: null,
                    status: 'active',
                    originalPriorityColor: null
                };
                project.tasks.push(newTask);
                saveProjects();
                renderTasks(project.tasks);
                setTimeout(() => {
                    const newTaskCard = document.querySelector(`[data-task-id="${newTask.id}"] .task-content`);
                    if (newTaskCard) newTaskCard.focus();
                }, 0);
            });

            bottomAddTaskBtn.addEventListener('click', () => {
                addTaskBtn.click();
            });

            // Event listener for priority color buttons (inside priority picker)
            document.querySelectorAll('.priority-color-btn').forEach(btn => {
                btn.addEventListener('click', (event) => {
                    const selectedColor = event.target.dataset.color;
                    const taskId = priorityPicker.dataset.currentTaskId;
                    const project = projects.find(p => p && p.id === currentProjectId);

                    if (project && taskId) {
                        const taskToUpdate = project.tasks.find(t => t.id === taskId);
                        if (taskToUpdate) {
                            taskToUpdate.priorityColor = selectedColor;
                            if (taskToUpdate.status === 'active') {
                                taskToUpdate.originalPriorityColor = selectedColor;
                            }
                            saveProjects();
                            renderTasks(project.tasks);
                        }
                    }
                    priorityPicker.classList.add('hidden');
                });
            });

            sortTasksBtn.addEventListener('click', () => {
                const project = projects.find(p => p && p.id === currentProjectId);
                if (project) {
                    const sortedTasks = [...project.tasks].sort((a, b) => {
                        const colorOrder = Object.keys(PRIORITY_COLORS);
                        const indexA = a.priorityColor ? colorOrder.indexOf(a.priorityColor) : colorOrder.length;
                        const indexB = b.priorityColor ? colorOrder.indexOf(b.priorityColor) : colorOrder.length;
                        return indexA - indexB;
                    });
                    project.tasks = sortedTasks;
                    saveProjects();
                    renderTasks(project.tasks);
                    showMessage('タスクを色順にソートしました', 'success');
                }
            });

            moveProjectBtn.addEventListener('click', () => {
                isMovingProjects = true;
                projectContextMenu.classList.add('hidden');
                renderHome();
                showMessage('プロジェクトをドラッグ＆ドロップで入れ替えてください', 'info', 5000);
            });

            deleteProjectBtn.addEventListener('click', () => {
                const projectIdToDelete = projectContextMenu.dataset.projectId;
                if (!projectIdToDelete) return;

                projectContextMenu.classList.add('hidden');
                confirmMessage.textContent = '本当にこのプロジェクトを削除しますか？';
                showModal(confirmModal);

                confirmYesBtn.onclick = () => {
                    const indexToDelete = projects.findIndex(p => p && p.id === projectIdToDelete);
                    if (indexToDelete !== -1) {
                        projects[indexToDelete] = null;
                        saveProjects();
                        renderHome();
                        showMessage('プロジェクトを削除しました', 'success');
                    }
                    hideModal(confirmModal);
                };

                confirmNoBtn.onclick = () => {
                    hideModal(confirmModal);
                };
            });

            changeProjectColorBtn.addEventListener('click', () => {
                const projectIdToChangeColor = projectContextMenu.dataset.projectId;
                if (!projectIdToChangeColor) return;

                projectContextMenu.classList.add('hidden');
                showModal(colorPickerModal);

                projectColorGrid.innerHTML = '';
                PROJECT_ICON_COLORS.forEach(color => {
                    const button = document.createElement('button');
                    button.classList.add('w-12', 'h-12', 'rounded-full', 'shadow-md', 'transition', 'duration-150', 'ease-in-out', 'transform', 'hover:scale-110', 'border-2', 'border-transparent');
                    button.style.backgroundColor = color;
                    button.dataset.color = color;
                    button.addEventListener('click', () => {
                        const project = projects.find(p => p && p.id === projectIdToChangeColor);
                        if (project) {
                            project.color = color;
                            saveProjects();
                            renderHome();
                            showMessage('プロジェクトの色を変更しました', 'success');
                        }
                        hideModal(colorPickerModal);
                    });
                    projectColorGrid.appendChild(button);
                });
            });

            closeColorPickerModalBtn.addEventListener('click', () => {
                hideModal(colorPickerModal);
            });

            // Global click handler
            document.addEventListener('click', (event) => {
                if (!projectContextMenu.classList.contains('hidden') && !projectContextMenu.contains(event.target) && !event.target.closest('.project-cell')) {
                    projectContextMenu.classList.add('hidden');
                }

                if (!priorityPicker.classList.contains('hidden') && !priorityPicker.contains(event.target) && !event.target.closest('.priority-btn')) {
                    priorityPicker.classList.add('hidden');
                }

                if (isMovingProjects) {
                    const clickedProjectCell = event.target.closest('.project-cell');
                    const clickedContextMenuButton = event.target.closest('.context-menu-btn');

                    if (!clickedProjectCell && !clickedContextMenuButton) {
                        isMovingProjects = false;
                        renderHome();
                        showMessage('プロジェクト移動モードを終了しました', 'info');
                    }
                }
            });
        });

        // Re-render home screen on window resize to adjust layout
        window.addEventListener('resize', () => {
            // Ensure homeScreen is defined before accessing its classList
            if (homeScreen && homeScreen.classList.contains('fade-enter-to')) {
                renderHome();
            }
        });
    </script>
</body>
</html>
